// listOf(T) types
// A list of objects
// - Supports views/pagination
'use @oigroup/lightscript with flippedImports'

import './type': { Type, typeName, typeOf }
import './helpers': { typeFrom, _setType }
import '../observe': { observableGhostSymbol, observable }
import 'observable-utils/lib/createSubject': createSubject

// List entry typechecks
typeCheck(T, ...vals) ->
  for elem val in vals:
    if val~looseEq(null) or (not T.validate(val)):
      throw new Error(`Element added to list must be of type '${typeName(T)}', was of type '${typeOf(val).name}'`)

class List:
  constructor(ListT) ->
    this~_setType(ListT)
    this.elementType = ListT.elementType
    this.__data = []

  // Add entries to the end of the list
  push(...entries): void ->
    if entries.length == 0: return
    typeCheck(this.elementType, ...entries)
    array = this.__data
    formerLength = array.length
    array.push(...entries)
    this[observableGhostSymbol]?.next({
      list: this
      type: "splice"
      index: formerLength
      deletions: []
      insertions: entries
    })

  // Add entries to the start of the list
  unshift(...entries): void ->
    if entries.length == 0: return
    typeCheck(this.elementType, ...entries)
    this.__data.unshift(...entries)
    this[observableGhostSymbol]?.next({
      list: this
      type: "splice"
      index: 0
      deletions: []
      insertions: entries
    })

  // Insert/delet entries at arbitrary point
  splice(i, n, ...entries): void ->
    if entries.length == 0: return
    typeCheck(this.elementType, ...entries)
    deletions = this.__data.splice(i, n, ...entries)
    this[observableGhostSymbol]?.next({
      list: this
      type: "splice"
      index: i
      deletions
      insertions: entries
    })

  // Iterate the list
  forEach(callback, thisArg): void ->
    this.__data.forEach(callback, thisArg)

  // Get ith entry
  get(i) ->
    this.__data[i]

  // Set ith entry
  set(i, val): void ->
    lastData = this.__data[i]
    if lastData == val: return
    typeCheck(this.elementType, val)
    this.__data[i] = val
    this[observableGhostSymbol]?.next({
      list: this
      type: "set"
      index: i
      previousValue: lastData
      nextValue: val
    })

  // Map
  map(callback, thisArg) ->
    this.__data.map(callback, thisArg)

class ListType extends Type:
  constructor(elementType) ->
    this.elementType = elementType
    this.name = `listOf(${elementType~typeName!})`

  construct() ->
    list = new List(this)
    _setType(list, this)
    list

  validate(x) ->
    x~looseEq(null) or (
      (x instanceof List)
      and (x.elementType.isKindOf(this.elementType))
    )

  isKindOf(T) ->
    T instanceof ListType
    and (this.elementType.isKindOf(T.elementType))

  getObservableForField(ent, k) ->
    list = ent[k]
    // This will automatically create the observable ghost, so...
    // `observable(parent).list` is equivalent to...
    // `observable(parent.list)`
    observable(list)

  createObservableGhost(ent) ->
    createSubject({
      onObserversChanged(observers, added, removed) ->
        if removed and observers.length == 0:
          ent[observableGhostSymbol] = undefined
    })

export listOf(T) ->
  now T = typeFrom(T)
  listT = new ListType(T)
  listT
